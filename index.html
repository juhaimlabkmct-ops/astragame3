<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>MALWARE NETWORK :: RED TEAM SIM</title>

  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap" rel="stylesheet">

  <style>
    :root {
      --primary: #00ff9c;
      --primary-glow: rgba(0, 255, 156, 0.4);
      --accent: #ff0040;
      --accent-glow: rgba(255, 0, 64, 0.4);
      --bg: #05070c;
      --panel: rgba(10, 15, 25, 0.8);
    }

    html,
    body {
      margin: 0;
      padding: 0;
      background: var(--bg);
      color: var(--primary);
      font-family: 'JetBrains Mono', monospace;
      overflow: hidden;
      touch-action: none;
      height: 100%;
    }

    h1 {
      color: var(--accent);
      text-align: center;
      margin: 10px 0;
      font-size: 1.2rem;
      text-transform: uppercase;
      letter-spacing: 4px;
      text-shadow: 0 0 15px var(--accent);
    }

    #wrap {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: space-between;
      position: relative;
      background: radial-gradient(circle at center, #101525 0%, #05070c 100%);
    }

    .game-container {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      overflow: hidden;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
      object-fit: contain;
      background: #000;
      box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
    }

    .ui-panel {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      width: 90%;
      max-width: 600px;
      display: flex;
      justify-content: space-around;
      padding: 8px;
      background: rgba(10, 15, 25, 0.6);
      border: 1px solid rgba(0, 255, 156, 0.2);
      border-radius: 4px;
      box-sizing: border-box;
      backdrop-filter: blur(10px);
      z-index: 50;
    }

    .stat-val {
      font-size: 16px;
      font-weight: bold;
      color: #fff;
      text-shadow: 0 0 10px var(--primary-glow);
    }

    .stat span:first-child {
      font-size: 9px;
      opacity: 0.7;
    }

    @media (min-width: 769px) {
      h1 {
        font-size: 2.5rem;
      }
    }

    #overlay {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.9);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      cursor: pointer;
      backdrop-filter: blur(15px);
    }

    .glitch-text {
      font-size: 28px;
      color: var(--primary);
      text-shadow: 2px 0 var(--accent), -2px 0 #00ffff;
      animation: glitch 2s infinite;
    }

    @keyframes glitch {
      0% {
        transform: translate(0);
      }

      20% {
        transform: translate(-2px, 2px);
      }

      40% {
        transform: translate(-2px, -2px);
      }

      60% {
        transform: translate(2px, 2px);
      }

      80% {
        transform: translate(2px, -2px);
      }

      100% {
        transform: translate(0);
      }
    }

    .stealth-bar-container {
      width: 100%;
      height: 4px;
      background: rgba(255, 255, 255, 0.1);
      margin-top: 5px;
      overflow: hidden;
    }

    #stealth-fill {
      width: 100%;
      height: 100%;
      background: var(--accent);
      box-shadow: 0 0 10px var(--accent);
      transition: width 0.1s linear;
    }
  </style>
</head>

<body>
  <div id="wrap" class="scanlines">
    <h1>Malware Network</h1>

    <div id="overlay">
      <div class="glitch-text">SYSTEM OFFLINE</div>
      <div style="font-size: 14px; margin-top:20px; color:#fff; letter-spacing: 2px;">[ TAP TO INJECT PAYLOAD ]</div>
      <div style="font-size: 10px; margin-top:40px; color:#555; text-align: center; line-height: 1.5;">
        SWIPE TO MOVE • DOUBLE TAP FOR STEALTH<br>
        COLLECT DATA & ZERO-DAYS • REACH THE GOLDEN NODE<br>
        AVOID DEFENSIVE FIREWALLS
      </div>
    </div>

    <div class="game-container">
      <div id="canvas-host"></div>

      <div class="ui-panel">
        <div class="stat">
          <span>DATA EXFIL</span>
          <span id="ui-score" class="stat-val">0000</span>
        </div>
        <div class="stat" style="align-items: center;">
          <span>STEALTH CHARGES</span>
          <span id="ui-zeros" class="stat-val">0</span>
        </div>
        <div class="stat" style="align-items: flex-end;">
          <span>NODE LINK</span>
          <span id="ui-level" class="stat-val">LVL 01</span>
        </div>
      </div>
      <div class="stealth-bar-container">
        <div id="stealth-fill"></div>
      </div>
    </div>

  </div>
  </div>

  <script>
    /* ================= AUDIO ENGINE ================= */
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const sound = {
      play(freq, type, duration, vol = 0.1) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        gain.gain.setValueAtTime(vol, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
        osc.start();
        osc.stop(audioCtx.currentTime + duration);
      },
      data() { this.play(880, 'square', 0.1, 0.05); },
      zero() { this.play(440, 'sine', 0.5, 0.1); this.play(660, 'sine', 0.5, 0.1); },
      stealth() {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.frequency.setValueAtTime(100, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.3);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
        gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.3);
      },
      crash() {
        for (let i = 0; i < 5; i++) this.play(100 + Math.random() * 200, 'sawtooth', 0.5, 0.1);
      },
      win() {
        [440, 554, 659, 880].forEach((f, i) => {
          setTimeout(() => this.play(f, 'sine', 0.4, 0.1), i * 150);
        });
      },
      powerup() { this.play(1200, 'sine', 0.2, 0.1); }
    };

    /* ================= HAPTICS ================= */
    const haptic = (ms) => {
      if (navigator.vibrate) navigator.vibrate(ms);
    };

    /* ================= CONSTANTS ================= */
    const UP = 1, LEFT = 2, DOWN = 3, RIGHT = 4;
    const KEY = { 37: LEFT, 38: UP, 39: RIGHT, 40: DOWN, 32: 'STEALTH', 82: 'RESET' };
    const FPS = 30;
    const SIZE = 32;

    /* ================= UTILS ================= */
    let shake = 0;
    const particles = [];
    class Particle {
      constructor(x, y, color) {
        this.x = x; this.y = y;
        this.vx = (Math.random() - 0.5) * 10;
        this.vy = (Math.random() - 0.5) * 10;
        this.alpha = 1;
        this.color = color;
      }
      update() {
        this.x += this.vx; this.y += this.vy;
        this.alpha -= 0.05;
      }
      draw(ctx) {
        ctx.globalAlpha = this.alpha;
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, 4, 4);
        ctx.globalAlpha = 1;
      }
    }

    function createExplosion(x, y, color, count = 10) {
      for (let i = 0; i < count; i++) particles.push(new Particle(x, y, color));
    }

    /* ================= MAP TILES ================= */
    const WALL = 0, DATA = 1, EMPTY = 2, ZERO = 3, GOAL = 4, POWERUP = 5;

    /* ================= ENGINE ================= */
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    document.getElementById('canvas-host').appendChild(canvas);

    /* ================= LEVELS ================= */
    const LEVELS = [
      [
        "000000000000000000000000000000",
        "0S11110001111111000111111111G0",
        "010001000100000100010000010000",
        "01110111111110Z111011111111110",
        "010001001000001000100000110000",
        "0111110111111P1111111111011110",
        "000001000000010000000000010000",
        "011110111111111111111110111110",
        "010000000001000000000100010000",
        "011111111110111111111111111110",
        "000001000000010000000000010000",
        "0111011111111Z1111111111111110",
        "010000000001000000000100010000",
        "011111P11111011111111111111110",
        "000001000000000001000000000000",
        "011110111111111111111111111110",
        "0100000000010000000001000101110",
        "011111111111Z11111111111111110",
        "000001000000000001000000000000",
        "011110111101111111111011111110",
        "010000000000000000000000000000",
        "0111111111P1111111111111111110",
        "010101010101010101010101010100",
        "011101111111111111111111111110",
        "0100010001000100010001000101110",
        "0111111111Z1111111111111111110",
        "010101010101010101010101010110",
        "0G1111111111111111111111111110",
        "000000000000000000000000000000"
      ],
      [
        "000000000000000000000000000000",
        "0S11100011111P10001111111111G0",
        "010111110000000000111111000000",
        "0111000111Z1110001111111011110",
        "000100000111110000000011010010",
        "0111111111111111111111P1010010",
        "010000000100000000010000011010",
        "01111Z11111111Z111111111010010",
        "000100000001000000010000010010",
        "011110111111111111110111011110",
        "010000000100000000010000000000",
        "01111P111111111111111111111110",
        "000100000001000000010000000010",
        "011111111111111111111111111110",
        "010000000100000000010000010000",
        "011111111Z11111111111111011110",
        "000100000001000000010000010000",
        "011111101111111111P11111111110",
        "010000000100000000010000010000",
        "011111111111111111111111111110",
        "010101010101010101010101010100",
        "01111Z11111111Z111111111111110",
        "000100000001000000010000000100",
        "011111111111111111111111111110",
        "010000000100000000010000010000",
        "011111111111111111111111111110",
        "010101010101010101010101010100",
        "01111P111111111111111111111110",
        "000000000000000000000000000000"
      ]
    ];

    let currentLevel = 0;
    function loadLevel(idx) {
      const l = LEVELS[idx % LEVELS.length];
      const map = l.map(r => r.split('').map(c => {
        if (c === '0') return WALL;
        if (c === '1') return DATA;
        if (c === 'S') return EMPTY;
        if (c === 'Z') return ZERO;
        if (c === 'P') return POWERUP;
        if (c === 'G') return GOAL;
        return EMPTY;
      }));
      canvas.width = map[0].length * SIZE;
      canvas.height = map.length * SIZE;
      return map;
    }

    /* ================= NETWORK ================= */
    const net = {
      map: [],
      init() { this.map = loadLevel(currentLevel); },
      draw() {
        for (let y = 0; y < this.map.length; y++) {
          for (let x = 0; x < this.map[0].length; x++) {
            let t = this.map[y][x];
            if (t === WALL) {
              ctx.strokeStyle = "#003344";
              ctx.strokeRect(x * SIZE + 2, y * SIZE + 2, SIZE - 4, SIZE - 4);
              // Decorate normal wall with "circuit" traces
              if (Math.random() > 0.95) {
                ctx.fillStyle = "#003344";
                ctx.fillRect(x * SIZE + SIZE / 2 - 1, y * SIZE, 2, SIZE);
              }
            }
            if (t === DATA) {
              ctx.fillStyle = "#00ffcc";
              ctx.fillRect(x * SIZE + SIZE / 2 - 2, y * SIZE + SIZE / 2 - 2, 4, 4);
              ctx.shadowColor = "#00ffcc";
              ctx.shadowBlur = 4;
              ctx.stroke();
              ctx.shadowBlur = 0;
            }
            if (t === ZERO) {
              ctx.fillStyle = "#ff00ff";
              ctx.beginPath();
              ctx.arc(x * SIZE + SIZE / 2, y * SIZE + SIZE / 2, 6, 0, Math.PI * 2);
              ctx.fill();
            }
            if (t === POWERUP) {
              ctx.fillStyle = "#00ffff";
              ctx.fillRect(x * SIZE + SIZE / 2 - 6, y * SIZE + SIZE / 2 - 6, 12, 12);
              ctx.strokeStyle = "#fff";
              ctx.strokeRect(x * SIZE + SIZE / 2 - 6, y * SIZE + SIZE / 2 - 6, 12, 12);
            }
            if (t === GOAL) {
              ctx.fillStyle = "#ffd700";
              ctx.shadowColor = "#ffd700";
              ctx.shadowBlur = 15;
              ctx.fillRect(x * SIZE + 4, y * SIZE + 4, SIZE - 8, SIZE - 8);
              ctx.shadowBlur = 0;
              // Goal animation
              ctx.strokeStyle = "#fff";
              ctx.strokeRect(x * SIZE + 6 + Math.sin(tick * 0.2) * 2, y * SIZE + 6 + Math.sin(tick * 0.2) * 2, SIZE - 12 - Math.sin(tick * 0.2) * 4, SIZE - 12 - Math.sin(tick * 0.2) * 4);
            }
          }
        }
      },
      wall(x, y) {
        let t = this.map[y]?.[x];
        return t === WALL || t === undefined;
      },
      eat(x, y) {
        let t = this.map[y][x];
        if (t === DATA || t === ZERO || t === POWERUP) this.map[y][x] = EMPTY;
        return t;
      }
    };

    /* ================= PAYLOAD ================= */
    const payload = {
      x: 1, y: 1, dir: RIGHT,
      stealth: false, stTick: 0,
      score: 0, zeros: 3,
      boost: 0, trail: [],
      moveTick: 0,
      moveDelay: 3,

      reset() {
        this.x = 1; this.y = 1; this.dir = RIGHT;
        this.stealth = false; this.boost = 0;
      },
      move(t) {
        this.moveTick++;
        let currentDelay = this.boost > 0 ? 1 : this.moveDelay;
        if (this.moveTick < currentDelay) return;
        this.moveTick = 0;
        if (this.boost > 0) this.boost--;

        let nx = this.x, ny = this.y;
        if (this.dir === LEFT) nx--;
        if (this.dir === RIGHT) nx++;
        if (this.dir === UP) ny--;
        if (this.dir === DOWN) ny++;

        if (!net.wall(nx, ny)) {
          this.x = nx; this.y = ny;
        }

        let e = net.eat(this.x, this.y);
        if (e === DATA) {
          this.score += 10;
          sound.data();
          createExplosion(this.x * SIZE + SIZE / 2, this.y * SIZE + SIZE / 2, "#00ffcc", 5);
        }
        if (e === ZERO) {
          this.zeros++;
          sound.zero();
          createExplosion(this.x * SIZE + SIZE / 2, this.y * SIZE + SIZE / 2, "#ff00ff", 15);
        }
        if (e === POWERUP) {
          this.boost = 60; // 2 seconds of speed
          sound.powerup();
          createExplosion(this.x * SIZE + SIZE / 2, this.y * SIZE + SIZE / 2, "#00ffff", 15);
        }
        if (e === GOAL) {
          sound.win();
          currentLevel++;
          if (currentLevel >= LEVELS.length) {
            gameOver = true;
            drawScoreboard(true);
          } else {
            this.reset();
            net.init();
            initDefenses();
          }
        }

        if (this.stealth) {
          this.trail.push({ x: this.x, y: this.y, alpha: 0.6 });
          if (t - this.stTick > 150) this.stealth = false;
        }
        this.trail.forEach(p => p.alpha -= 0.02);
        this.trail = this.trail.filter(p => p.alpha > 0);
      },
      draw() {
        this.trail.forEach(p => {
          ctx.fillStyle = `rgba(255,0,64,${p.alpha})`;
          ctx.fillRect(p.x * SIZE + 8, p.y * SIZE + 8, SIZE - 16, SIZE - 16);
        });

        ctx.save();
        ctx.translate(this.x * SIZE + SIZE / 2, this.y * SIZE + SIZE / 2);
        if (this.boost > 0) {
          ctx.strokeStyle = "#00ffff";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(0, 0, 15 + Math.sin(tick * 0.5) * 5, 0, Math.PI * 2);
          ctx.stroke();
        }
        ctx.globalAlpha = this.stealth ? 0.3 : 1;
        ctx.shadowColor = "#ff0040";
        ctx.shadowBlur = 15;
        ctx.fillStyle = "#ff0040";
        ctx.beginPath();
        ctx.arc(0, 0, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    };

    /* ================= DEFENSE ================= */
    class Defense {
      constructor(type, x, y, speed = 5) {
        this.type = type; this.x = x; this.y = y;
        this.spawnX = x; this.spawnY = y;
        this.moveTick = 0; this.moveDelay = speed;
        this.pulse = Math.random() * 10;
        this.dir = Math.floor(Math.random() * 4) + 1;
      }
      move() {
        if (payload.stealth) return;
        this.moveTick++;
        if (this.moveTick < this.moveDelay) return;
        this.moveTick = 0;

        if (this.type === "FOLLOW") {
          let dx = payload.x - this.x, dy = payload.y - this.y;
          if (Math.abs(dx) > Math.abs(dy)) {
            if (dx > 0 && !net.wall(this.x + 1, this.y)) this.x++;
            else if (dx < 0 && !net.wall(this.x - 1, this.y)) this.x--;
            else if (dy > 0 && !net.wall(this.x, this.y + 1)) this.y++;
            else if (dy < 0 && !net.wall(this.x, this.y - 1)) this.y--;
          } else {
            if (dy > 0 && !net.wall(this.x, this.y + 1)) this.y++;
            else if (dy < 0 && !net.wall(this.x, this.y - 1)) this.y--;
            else if (dx > 0 && !net.wall(this.x + 1, this.y)) this.x++;
            else if (dx < 0 && !net.wall(this.x - 1, this.y)) this.x--;
          }
        } else {
          // Random/Patrol
          let nx = this.x, ny = this.y;
          if (this.dir === UP) ny--; if (this.dir === DOWN) ny++;
          if (this.dir === LEFT) nx--; if (this.dir === RIGHT) nx++;
          if (net.wall(nx, ny)) this.dir = Math.floor(Math.random() * 4) + 1;
          else { this.x = nx; this.y = ny; }
        }
        this.pulse += 0.2;
      }
      draw() {
        ctx.save();
        ctx.translate(this.x * SIZE + SIZE / 2, this.y * SIZE + SIZE / 2);
        ctx.rotate(this.pulse * 0.5);
        const colors = { FOLLOW: "#ff3c3c", PATROL: "#00f5ff", SCOUT: "#aa00ff" };
        ctx.fillStyle = colors[this.type];
        let s = 10 + Math.sin(this.pulse) * 3;
        ctx.fillRect(-s, -s, s * 2, s * 2);
        ctx.strokeStyle = "#fff";
        ctx.strokeRect(-s, -s, s * 2, s * 2);
        ctx.restore();
      }
    }

    let defenses = [];
    function initDefenses() {
      defenses = [
        new Defense("FOLLOW", 10, 5, 6),
        new Defense("PATROL", 15, 3, 4),
        new Defense("SCOUT", 5, 2, 5)
      ];
      if (currentLevel > 0) defenses.push(new Defense("FOLLOW", 20, 5, 5));
    }

    /* ================= UI UPDATES ================= */
    function updateUI() {
      document.getElementById('ui-score').innerText = payload.score.toString().padStart(4, '0');
      document.getElementById('ui-zeros').innerText = payload.zeros;
      document.getElementById('ui-level').innerText = `LVL ${(currentLevel + 1).toString().padStart(2, '0')}`;

      const stealthPct = payload.stealth ? Math.max(0, 100 - (tick - payload.stTick) / 1.5) : 100;
      document.getElementById('stealth-fill').style.width = stealthPct + "%";
      document.getElementById('stealth-fill').style.background = payload.stealth ? "var(--primary)" : "var(--accent)";
    }

    /* ================= GAME STATE ================= */
    let tick = 0, gameStarted = false, gameOver = false;

    /* ================= INPUT ================= */
    const handleAction = (act) => {
      if (gameOver) return;
      if (act === 'STEALTH') {
        if (payload.zeros > 0 && !payload.stealth) {
          payload.stealth = true; payload.stTick = tick;
          payload.zeros--; sound.stealth(); haptic(100);
        }
      } else if (typeof act === 'number') payload.dir = act;
    };

    document.addEventListener('keydown', e => {
      if ([32, 37, 38, 39, 40].includes(e.keyCode)) e.preventDefault();
      if (KEY[e.keyCode] === 'RESET') location.reload();
      handleAction(KEY[e.keyCode]);
    });

    /* ================= GESTURE CONTROLS ================= */
    let tStartX = 0, tStartY = 0, lastTap = 0;

    document.addEventListener('touchstart', e => {
      tStartX = e.touches[0].clientX;
      tStartY = e.touches[0].clientY;
      const now = Date.now();
      if (now - lastTap < 300) handleAction('STEALTH');
      lastTap = now;
    }, { passive: false });

    document.addEventListener('touchend', e => {
      const dx = e.changedTouches[0].clientX - tStartX;
      const dy = e.changedTouches[0].clientY - tStartY;
      if (Math.abs(dx) > Math.abs(dy)) {
        if (Math.abs(dx) > 30) handleAction(dx > 0 ? RIGHT : LEFT);
      } else {
        if (Math.abs(dy) > 30) handleAction(dy > 0 ? DOWN : UP);
      }
    }, { passive: false });

    document.addEventListener('touchmove', e => {
      if (gameStarted && !gameOver) e.preventDefault();
    }, { passive: false });

    document.getElementById('overlay').onclick = function () {
      this.style.display = 'none';
      gameStarted = true;
      audioCtx.resume();
      net.init();
      initDefenses();
    };

    /* ================= LOOP ================= */

    function drawScoreboard(win) {
      ctx.fillStyle = "rgba(0,0,0,0.9)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = win ? "var(--primary)" : "var(--accent)";
      ctx.font = "24px 'JetBrains Mono'";
      ctx.textAlign = "center";
      ctx.fillText(win ? "INFILTRATION COMPLETE" : "LINK SEVERED", canvas.width / 2, canvas.height / 2 - 20);
      ctx.font = "14px 'JetBrains Mono'";
      ctx.fillStyle = "#fff";
      ctx.fillText(`FINAL SCORE: ${payload.score}`, canvas.width / 2, canvas.height / 2 + 20);
      ctx.fillText("TAP SCREEN TO REBOOT", canvas.width / 2, canvas.height / 2 + 60);
    }

    canvas.onpointerdown = () => { if (gameOver) location.reload(); };

    setInterval(() => {
      if (!gameStarted || gameOver) return;
      tick++;

      ctx.save();
      if (shake > 0) {
        ctx.translate((Math.random() - 0.5) * shake, (Math.random() - 0.5) * shake);
        shake *= 0.8;
      }

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      net.draw();
      payload.move(tick);
      payload.draw();

      defenses.forEach(d => {
        d.move(); d.draw();
        if (!payload.stealth && d.x === payload.x && d.y === payload.y) {
          shake = 20; sound.crash(); haptic([200, 100]);
          gameOver = true; drawScoreboard(false);
        }
      });

      for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].update();
        particles[i].draw(ctx);
        if (particles[i].alpha <= 0) particles.splice(i, 1);
      }

      ctx.restore();
      updateUI();
    }, 1000 / FPS);
  </script>
</body>

</html>